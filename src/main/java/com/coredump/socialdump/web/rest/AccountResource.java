package com.coredump.socialdump.web.rest;

import com.codahale.metrics.annotation.Timed;
import com.coredump.socialdump.domain.Authority;
import com.coredump.socialdump.domain.User;
import com.coredump.socialdump.repository.UserRepository;
import com.coredump.socialdump.security.SecurityUtils;
import com.coredump.socialdump.service.MailService;
import com.coredump.socialdump.service.UserService;
import com.coredump.socialdump.web.rest.dto.UserDTO;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.*;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller for managing the current user's account.
 * Generated by JHipster.
 */
@RestController
@RequestMapping("/api")
public class AccountResource {

  /**
   * Escritor de bitácoras de la clase.
   */
  private final Logger log = LoggerFactory.getLogger(AccountResource.class);

  /**
   * Repositorio de usuarios.
   */
  @Inject
  private UserRepository userRepository;

  /**
   * Servicio de usuarios.
   */
  @Inject
  private UserService userService;

  /**
   * Servicio de correos electrónicos de la alicación.
   */
  @Inject
  private MailService mailService;

  /**
   * POST  /register -> register the user.
   */
  @RequestMapping(value = "/register",
    method = RequestMethod.POST,
    produces = MediaType.TEXT_PLAIN_VALUE)
  @Timed
  public ResponseEntity<?> registerAccount(@Valid @RequestBody UserDTO
                                             userDTO, HttpServletRequest request) {
    return userRepository.findOneByLogin(userDTO.getLogin())
      .map(user -> new ResponseEntity<>("login already in use",
        HttpStatus.BAD_REQUEST))
      .orElseGet(() -> userRepository.findOneByEmail(userDTO.getEmail())
          .map(user ->
            new ResponseEntity<>("e-mail address already in use",
              HttpStatus.BAD_REQUEST))
          .orElseGet(() -> {
            User user = userService
              .createUserInformation(userDTO.getLogin(),
                userDTO.getPassword(),
                userDTO.getFirstName(), userDTO.getLastName(),
                userDTO.getEmail().toLowerCase(),
                userDTO.getLangKey());
            String baseUrl = request.getScheme() +
              "://" +
              request.getServerName() +
              ":" +
              request.getServerPort();

            mailService.sendActivationEmail(user, baseUrl);
            return new ResponseEntity<>(HttpStatus.CREATED);
          })
      );
  }

  /**
   * GET  /activate -> activate the registered user.
   */
  @RequestMapping(value = "/activate",
    method = RequestMethod.GET,
    produces = MediaType.APPLICATION_JSON_VALUE)
  @Timed
  public ResponseEntity<String> activateAccount(
    @RequestParam(value = "key") String key) {
    return Optional.ofNullable(userService.activateRegistration(key))
      .map(user -> new ResponseEntity<String>(HttpStatus.OK))
      .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));
  }

  /**
   * GET  /authenticate -> check if the user is authenticated,
   * and return its login.
   */
  @RequestMapping(value = "/authenticate",
    method = RequestMethod.GET,
    produces = MediaType.APPLICATION_JSON_VALUE)
  @Timed
  public String isAuthenticated(HttpServletRequest request) {
    log.debug("REST request to check if the current user is authenticated");
    return request.getRemoteUser();
  }

  /**
   * GET  /account -> get the current user.
   */
  @RequestMapping(value = "/account",
    method = RequestMethod.GET,
    produces = MediaType.APPLICATION_JSON_VALUE)
  @Timed
  public ResponseEntity<UserDTO> getAccount() {
    return Optional.ofNullable(userService.getUserWithAuthorities())
      .map(user -> {
        return new ResponseEntity<>(
          new UserDTO(
            user.getId(),
            user.getLogin(),
            null,
            user.getFirstName(),
            user.getLastName(),
            user.getEmail(),
            user.getLangKey(),
            user.getAuthorities().stream().map(Authority::getName)
              .collect(Collectors.toList())),
          HttpStatus.OK);
      })
      .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));
  }

  /**
   * POST  /account -> update the current user information.
   */
  @RequestMapping(value = "/account",
    method = RequestMethod.POST,
    produces = MediaType.APPLICATION_JSON_VALUE)
  @Timed
  public ResponseEntity<String> saveAccount(@RequestBody UserDTO userDTO) {
    return userRepository
      .findOneByLogin(userDTO.getLogin())
      .filter(u -> u.getLogin().equals(SecurityUtils.getCurrentLogin()))
      .map(u -> {
        userService.updateUserInformation(userDTO.getFirstName(),
          userDTO.getLastName(), userDTO.getEmail(),
          userDTO.getLangKey());
        return new ResponseEntity<String>(HttpStatus.OK);
      })
      .orElseGet(() -> new ResponseEntity<>(
        HttpStatus.INTERNAL_SERVER_ERROR));
  }

  /**
   * POST  /change_password -> changes the current user's password
   */
  @RequestMapping(value = "/account/change_password",
    method = RequestMethod.POST,
    produces = MediaType.APPLICATION_JSON_VALUE)
  @Timed
  public ResponseEntity<?> changePassword(@RequestBody String password) {
    if (!checkPasswordLength(password)) {
      return new ResponseEntity<>("Incorrect password",
        HttpStatus.BAD_REQUEST);
    }
    userService.changePassword(password);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  /**
   * Solicita el reinicio de la contraseña.
   * @param mail correo electrónico.
   * @param request solicitud HTTP.
   * @return respuesta HTTP.
   */
  @RequestMapping(value = "/account/reset_password/init",
    method = RequestMethod.POST,
    produces = MediaType.TEXT_PLAIN_VALUE)
  @Timed
  public ResponseEntity<?> requestPasswordReset(@RequestBody String mail,
                                                HttpServletRequest request) {

    return userService.requestPasswordReset(mail)
      .map(user -> {
        String baseUrl = request.getScheme() +
          "://" +
          request.getServerName() +
          ":" +
          request.getServerPort();
        mailService.sendPasswordResetMail(user, baseUrl);
        return new ResponseEntity<>("e-mail was sent", HttpStatus.OK);
      }).orElse(new ResponseEntity<>("e-mail address not registered",
        HttpStatus.BAD_REQUEST));

  }

  /**
   * Completa el reseteo de la contraseña.
   * @param key hash utilizado para validar el cambio de contraseña.
   * @param newPassword nuevo password a utilizar.
   * @return respuesta HTTP.
   */
  @RequestMapping(value = "/account/reset_password/finish",
    method = RequestMethod.POST,
    produces = MediaType.APPLICATION_JSON_VALUE)
  @Timed
  public ResponseEntity<String> finishPasswordReset(
    @RequestParam(value = "key") String key,
    @RequestParam(value = "newPassword") String newPassword) {
    if (!checkPasswordLength(newPassword)) {
      return new ResponseEntity<>("Incorrect password",
        HttpStatus.BAD_REQUEST);
    }
    return userService.completePasswordReset(newPassword, key)
      .map(user -> new ResponseEntity<String>(HttpStatus.OK))
      .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));
  }

  /**
   * Valida la longitud de una contraseña.
   * @param password contraseña.
   * @return si es válida.
   */
  private boolean checkPasswordLength(String password) {
    return (!StringUtils.isEmpty(password) &&
      password.length() >= UserDTO.PASSWORD_MIN_LENGTH &&
      password.length() <= UserDTO.PASSWORD_MAX_LENGTH);
  }
}
